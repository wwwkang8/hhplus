## 동시성 이슈에 대한 분석
## 동시성 이슈가 있는 기능 : 좌석 선점(예약), 포인트 충전
- 동시에 여러명이 좌석을 예약시도를 하는 경우 동시성 문제가 발생할 수 있다. 이런 이유로 해당 좌석에 대해서 락을 걸어 동시성을 제어해야 한다.
- 사용자가 포인트 충전시에 따닥 빠르게 누르거나, 서로 다른 웹 브라우저에서 API를 동시에 호출하는 경우 동시성 문제 발생가능하다. 

### 낙관적 락(Optimistic Lock) - 좌석 예약에 적합!!
낙관적 락은 충돌 빈도가 적고, 동시 요청 중 1건만 성공하는 케이스에 적합하다.(ex. 티켓 예약시스템)
읽은 시점과 수정 시점의 데이터 변경 여부를 확인하기 때문에 Lock이 걸리지 않아 성능이 좋다.
  구현복잡도 : 낮음
엔티티에 Version을 추가하고, JpaRepository 쿼리에 낙관적락 설정.
  성능 : 높음
테이블 조회에 대한 락이 걸리지 않고, 데이터가 수정된 시점의 버전을 비교하기 때문에 요청에 대한 대기가 적다.
하지만 요청에 실패한 트랜잭션은 모두 보상 트랜잭션으로 롤백이 되기 때문에 충돌빈도가 높다면 성능이 저하될 가능성이 있습니다.
효율성 : 충돌 빈도에 따라 다르다
충돌 빈도가 낮다면 낙관적 락이 성능면에서 우위에 있다. 하지만 

### 비관적 락(Pessimistic Lock) - 포인트 잔액 충전에 적합!!
비관적 락은 충돌 빈도가 많고, 순차적으로 처리해야 하는 경우 적합(ex. 재고차감, 금융시스템)
공유락, 배타락에 따라서 성능이 저하될 수 있다.

구현복잡도 : 높음.
구현 복잡도가 높은 이유는 특정 엔티티에 비관락을 걸었는데, 이 락이 전파가 되어서 다른 테이블 접근도 막아서
데드락이 발생할 수도 있습니다. 그래서 락 전파를 고려하여 테이블 설계를 해야 합니다.
성능 : 보통.
효율성 : 데이터의 일관성이 중요한 도메인에서는 효율성이 좋다.

### 분산락(Redis Pub/Sub 락) - 좌석 예약에 적합
Redis를 활용해서 분산락을 설정
스핀락, 심플락, Pub/Sub 등등 구현 가능하다.

구현복잡도 : 높음
락의 획득, 락 해제, 락의 만료시간 등으 고려해서 구현해야합니다.
특히 락의 만료시간을 설정해야 락을 획득하지 못한 상태로 무한정 대기하지 않을 수 있다.

성능 : 높음
Redisson의 Pub/Sub 방식으로 분산락을 구현하게 되면, 스핀락보다 레디스에 부하가 덜 발생한다.

![image](https://github.com/wwwkang8/hhplus/assets/26863285/8c9625e5-9d43-4f5c-abff-9501adcf6865)



## 브랜치 전략
### 1. dev, prod 2개로 분리
- 서버 환경을 dev, prod 2개로 분리한다.
각각의 역할은 다음과 같습니다.
- dev : 신규로 개발한 내용을 반영하고 테스트 해보는 곳. 개발자들이 개발하고 테스트 하는 환경
- prod : 실제 운영환경으로 외부 API가 모두 연결되어 있고, 사용자들이 사용하는 환경.

## 트러블 슈팅
### 1. 대기열 구현 방식에 대한 고민
대기열을 구현한 이유는 50명의 사용자만 예약이 가능하도록 제한을 뒀기 때문이다.
만약에 수 천명의 사용자가 동시에 접속을 하면 대기열에 사용자들을 순서대로 INSERT 한다.
그런데 대기열에 있는 사용자들의 상태값을 변경해주고, 몇 명이 추가로 예약이 가능한지를 확인해주는 무언가가 필요했다.
그래서 스프링에서 제공하는 @Schedule 기능을 사용하여 이를 해결했다.
1분마다 현재 예약중인 사용자를 확인하고, 빈 자리가 생기면 대기중인 사용자를 예약 가능하도록 상태를 바꿔준다.
또한 토큰의 만료시각이 지난 사용자들도 토큰만료로 상태값을 변경해주는 역할을 한다.
하지만 스케쥴러도 한계점이 있다. 그 이유는 초실시간이 아니기 때문이다. 1분주기로 돌기 때문에 완벽한 실시간이라고 보기는 어렵다.

### 2. 레이어드 아키텍쳐 + 클린 아키텍쳐 도입
기존에는 Controller <-> Service <-> Repository 구조를 사용했었다.
하지만 이 구조의 한계점은 api, batch, admin 등 구현해야 하는 프로젝트가 많을수록 핵심 비즈니스 로직이 모여있는
Service 레이어에 모든 책임이 부여된다. 그리고 Service 레이어에 책임이 많아지면 결국 강결합이 발생하여 영향도가 높아진다.
이를 해결하고자 레이어드 아키텍쳐 + 클린아키텍쳐를 도입했다.
레이어드 아키텍쳐를 도입해서 각 레이어마다 Interface를 적용했다. 이 방식으로 각 레이어는 하위 레이어가 어떻게 구현되었는지 상관없이
인터페이스만 보고 호출하면 되어 결합도를 낮췄다. 하지만 JpaRepository가 인터페이스다보니 단위테스트가 어려웠다. 그래서
Repository Interface를 두고 그것을 구현하는 RepositoryImpl 클래스를 생성했다. 그리고 JpaRepository를 주입받는 형태로 개발하여
결합도를 낮추고 단위테스트를 용이하게 하였다.
클린아키텍쳐로는 UseCase 레이어를 도입한 것이 효과적이었다. 각 도메인별로 비즈니스 로직을 모두 구현해놓고, UseCase에서 필요에 맞게
모듈을 호출해서 사용하는 방식이다. 이 방식이 좋은 점은 도메인 로직별로 독립적으로 존재하여 결합도가 낮고, 재사용이 매우 용이하다.

### 3. 테이블 설계
ERD 설계 초기에는 Concert 테이블과 Seat 테이블을 합쳐서 설계를 했다. 이렇게 생각했던 이유는 Join을 최소화 하여 성능을 높이고자 했기 때문이다.
하지만 그렇게 하면 아래와 같은 문제점이 있다.
 - 콘서트ID, 좌석번호, 공연일자를 PK로 복합키를 설정해야 한다. 해당 데이터를 조회하기 위해서 이 3개의 PK에 모두 인덱스가 걸린다.
   그렇게 되면 데이터가 많아지면 읽기 성능이 떨어진다. 왜? PK 모두에 인덱스가 걸리기 때문에 인덱스로 조회하는데 시간이 오래 걸리고
   복합키 중 하나라도 누락되거나, 순서가 다르면 조회시에 INDEX를 타지 않는 경우도 발생.
- 다른 테이블에서 복합키를 FK로 가져가야 하는데 그렇게 되면 FK가 많아져서 성능이 저하.

### 4. 동시성 제어에 대한 고민 - 낙관락, 비관락, 분산락 등등 => 작성 예정

### 5. 


## 시나리오 요구사항 분석(콘서트 예약시스템)
[유저 대기열 API]
- 토큰 발급 및 대기열 추가 : UUID + 유저 아이디 + wait_no
- 대기열 검증 : 토근 발급 이후, 모든 API 요청은 대기열에 해당 사용자가 존재하는지 검증
- (폴링) 대기열 상태 확인 : 폴링 방식으로 현재 유저의 대기상태 확인. @Schedule 스케쥴러로 매 시간마다 확인 후 갱신
** 매 분마다 N명씩 추가로 입장 가능하도록 개발

[예약가능날짜/좌석 API]
- 예약가능일자 조회 : 예약 가능한 날짜 조회 기능
- 좌석정보 조회 : 해당 날짜의 좌석정보 조회 기능(1~50번의 좌석번호 반환)

[좌석예약요청 API]
- 좌석 예약 기능 : 좌석번호, 날짜를 입력 받아 예약
- 임시 배정 기능 : 좌석 예약시 5분간 사용자에게 배정. 5분이 지나면 다른 사용자에게 좌석조회시 보여지게 됨.

[잔액 충전/조회 API]
- 잔액 충전 : 사용자 식별자(아이디), 충전할 금액 받아서 충전
- 잔액 조회 : 사용자 식별자(아이디)로 잔액 조회

[결제 API]
- 결제 : 사용자의 잔액을 사용하여 결제처리 하고, 결제내역 생성.
- 대기열 만료 : 사용자에게 좌석 배정 후, 대기열 만료처리.

## 구현 방식에 대한 고민
### 1. 유저 대기열 토큰 기능
1. 고객 진입 : POST  /api/queue
  1-1. 헤더에 토큰이 없는 경우 => 토큰(사용자ID+UUID) 발행 => 토큰, 사용자 테이블 INSERT
  1-2. 헤더에 토큰이 있는 경우 => 토큰에서 사용자ID 추출 => 토큰 테이블에서 순번 조회
2. @Scheduled  스케쥴러가 대기열에서 현재 몇 명이 ONGOING 상태인지 확인 => 50명 미만? 그러면 wait_no 순서대로 상태변경
3. 토큰 발급 여부를 이후 API에서 Filter로 검증

### 2. 내 대기 순번 조회 기능
1. 고객 진입 : POST  /api/queue/{userId}
  1-1. 방법 : 내 wait_no - 상태가 ONGOING인 사용자의 마지막 wait_no
  1-2. 장점 : 상태가 ONGOING인 사용자들만 조회해도 되기 때문에 대기열 테이블 전체를 조회하는 것을 피할 수 있다.(성능 향상)
![image](https://github.com/wwwkang8/hhplus/assets/26863285/1a072d9a-23ec-4933-95b8-78f4fda8f7f5)



### 3. 좌석 임시배정
1. 고객이 좌석 예약 : POST  /api/reservation
   1-1. 좌석테이블에 사용자ID, 임시배정만료시각(~5분), 상태값(RESERVED) 세팅
2. @Scheduled 스케쥴러가 대기열에서 현재 시각을 기준으로 임시배정만료시각이 지난 좌석은 상태값(AVAILABLE)로 갱신




## 시퀀스 다이어그램
![image](https://github.com/wwwkang8/hhplus/assets/26863285/55d3efb0-1508-4812-af52-7d6ea093fd18)



## 아키텍쳐
- 레이어드 아키텍쳐 + 클린 아키텍쳐
- 도메인별로 다른 패키지 구조를 설계.
- 추후 Service 로직이 비대해지는 것을 방지하기 위해서 Usecase 모델을 추가.
  Controller --> Usecase --> Repository 방향으로 단방향 호출 방식

## API 명세
![image](https://github.com/wwwkang8/hhplus/assets/26863285/7f800487-8042-46f5-acad-4f0794d84e09)


### [1. 대기열 진입]
사용자가 대기열에 진입합니다. 진입시 토큰, 사용자ID, 대기번호를 발급 받습니다.
| 메서드 | 요청 URL | 기능 |
|--------|-----------------| -----------|
| POST    |/api/queue/     | 대기열 진입   |

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------| ----------|----------|
| 없음     |         |           |          |

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|----------------|-----|------------------|
| token  |String    |필수  |토큰|
| userId |Long    |필수  |사용자ID|
| waitNo |Long    |필수  |대기순번|

### [1-1. 대기열 순번 조회]
대기열 순번을 조회하는 폴링 API

| 메서드 | 요청 URL | 기능 |
|--------|-----------------| -----------|
| GET    |/api/queue| 대기열 순번 조회 |

Request(헤더부)
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------| ----------|----------|
| token  |String    |필수        |사용자의 토큰|

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|----------------|-----|------------------|
| token  |String    |필수  |토큰|
| userId |Long    |필수  |사용자ID|
| waitNo |Long    |필수  |대기순번|



### [2. 예약 가능 날짜조회]
좌석 예약이 가능한 날짜를 조회합니다.

| 메서드 | 요청 URL | 기능 |
|--------|--------------------------| -----------|
| GET    |/api/concert/{concertId}  | 예약가능날짜조회|

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------| ----------|----------|
|concertId| Long |  필수     | 콘서트아이디   |

현재 시점에서 예약 가능한 콘서트의 모든 날짜를 리턴. 따라서 파라메터를 따로 입력받지 않습니다.

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|----------------|-----|------------------|
|concertId|Long  |필수  |콘서트 아이디|
|date   |List<String>    |필수  |예약 가능한 날짜|

### [3. 특정날짜의 예약가능한 좌석조회]
| 메서드 | 요청 URL | 기능 |
|--------|-----------------------------------------------|-----------------------|
| GET    |/api/concert/{concertId}/calendar/{concertDate}|해당날짜의 콘서트 예약가능한 좌석조회|

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------|-----|----------|
|concertId| Long| 필수 | 콘서트아이디|
|concertDate| String| 필수 | 예약날짜|

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|----------------|-----|-------------------|
| seat   |List<String>    |필수  |예약 가능한 좌석번호리스트|


### [4. 좌석 예약]
| 메서드 | 요청 URL | 기능 |
|--------|------------|----------|
| POST   |/api/reservation/| 콘서트 예약 |

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------|-----|----------|
|userId |Long| 필수 |사용자아이디|
|token |String| 필수 |토큰|
|concertId |Long| 필수 |콘서트 아이디|
|concertDate|String| 필수 |예약날짜|
|seatNo|Long| 필수 |좌석번호|

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|----------------|-----|-------------------|
|userId|Long    |필수  |사용자 아이디|
|concertId|Long    |필수  |콘서트 아이디|
|seatNo|Long    |필수  |임시배정된 좌석번호|
|expiredAt|LocalDateTime|필수  |임시배정된 좌석만료시각|

### [5. 포인트 조회]
| 메서드 | 요청 URL | 기능 |
|--------|----------|----------|
| GET     |/api/point/{userId}| 포인트 조회|

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------|-----|----------|
|userId |long| 필수 |사용자아이디|

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|--------|-----|--------|
| userId|long |필수  |사용자아이디|
| point|Integer |필수  |포인트 잔액|

### [6. 포인트 충전]
| 메서드 | 요청 URL |기능|
|--------|----------|----------|
| POST     |/api/point/charge| 포인트 충전   |

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|--------|----------|-----|----------|
|userId |long| 필수 |사용자아이디|
|amount |Integer| 필수 |충전할 포인트 금액|

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|--------|-----|--------|
| point|Integer |필수  |포인트 잔액|

### [7. 결제]
| 메서드 | 요청 URL |기능|
|--------|----------|----------|
| POST     |/api/payment/| 결제  |

Request
| 파라메터 | 타입 | 필수여부 | 설명 |
|-----------|----------|-----|----------|
|userId |long| 필수 |사용자아이디|
|token |String| 필수 |토큰|
|concertId |long| 필수 |콘서트 아이디|
|concertDate|LocalDate| 필수 |예약 날짜|
|seatNo |long| 필수 |예약 좌석번호|

Response
| 필드 | 타입 | 필수여부 | 설명 |
|--------|--------|-----|--------|
|userId|long |필수  |사용자 아이디|
|concertId |long| 필수 |콘서트 아이디|
|concertDate|LocalDate| 필수 |예약 날짜|
|seatNo |long| 필수 |예약 좌석번호|
|result|String |필수  |좌석예약 성공여부|

## ERD 구조
![image](https://github.com/wwwkang8/hhplus/assets/26863285/7349bb82-bfda-4444-afb4-bae2ae930add)

1) 사용자 테이블뿐만 아니라 대기열 테이블에도 사용자 아이디를 넣은 이유는 대기열 테이블의 경우 대기상태를 계속해서 체크해야 하므로
조회 거래가 많을 것으로 예상된다. 다른 테이블과 JOIN을 하여 성능을 저하시키기보다는 애초에 대기열 테이블에 토큰을 넣는 것이 효율적이라고 판단.
2) 대기열 테이블 : 사용자가 예약시스템 접속시 사용자ID가 생성되고, 동시에 토큰 발급한다. 그리고 토큰의 유효시간을 둬서 예약을 중도포기하는 사용자를 대기열에서 제거
3) 사용자 테이블 : 사용자테이블에는 아이디와 포인트 잔액이 존재. 토큰이 대기열, 사용자 테이블 모두에 있는 이유는 JOIN을 최소화 하기 위함.
4) 예약 테이블 : 예약테이블은 좌석 결제를 마친 후에 데이터가 생성되는 테이블. 결제내역 테이블과 동일한 기능.
5) 공연 테이블 : 공연에 대한 정보를 가지는 테이블
6) 좌석 테이블 : 좌석에 대한 정보를 가짐. 임시배정 사용자, 임시배정 만료시각이 있어서 현재 좌석의 상태에 따라서 예약 가능여부를 보여줄 수 있음.
